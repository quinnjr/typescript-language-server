//! Node modules resolution
//! Reserved for cross-file navigation features

#![allow(dead_code)]

use std::path::{Path, PathBuf};

/// Resolve a module from node_modules
pub fn resolve_node_module(specifier: &str, from_dir: &Path) -> Option<PathBuf> {
    // Split the specifier into package name and subpath
    let (package_name, subpath) = parse_package_specifier(specifier);

    // Walk up directory tree looking for node_modules
    let mut current_dir = from_dir.to_path_buf();

    loop {
        let node_modules = current_dir.join("node_modules");

        if node_modules.is_dir() {
            let package_dir = node_modules.join(&package_name);

            if package_dir.is_dir() {
                // Try to resolve within the package
                if let Some(resolved) = resolve_package_entry(&package_dir, subpath.as_deref()) {
                    return Some(resolved);
                }
            }
        }

        // Move up to parent directory
        if let Some(parent) = current_dir.parent() {
            current_dir = parent.to_path_buf();
        } else {
            break;
        }
    }

    None
}

/// Parse a package specifier into package name and subpath
fn parse_package_specifier(specifier: &str) -> (String, Option<String>) {
    if specifier.starts_with('@') {
        // Scoped package: @scope/package or @scope/package/subpath
        let parts: Vec<&str> = specifier.splitn(3, '/').collect();
        if parts.len() >= 2 {
            let package_name = format!("{}/{}", parts[0], parts[1]);
            let subpath = if parts.len() == 3 {
                Some(parts[2].to_string())
            } else {
                None
            };
            return (package_name, subpath);
        }
    }

    // Regular package: package or package/subpath
    let parts: Vec<&str> = specifier.splitn(2, '/').collect();
    let package_name = parts[0].to_string();
    let subpath = parts.get(1).map(|s| s.to_string());

    (package_name, subpath)
}

/// Resolve a package entry point
fn resolve_package_entry(package_dir: &Path, subpath: Option<&str>) -> Option<PathBuf> {
    if let Some(subpath) = subpath {
        // Resolve subpath within package
        let target = package_dir.join(subpath);
        return try_resolve_file(&target);
    }

    // Try package.json exports/main
    let package_json = package_dir.join("package.json");
    if package_json.is_file() {
        if let Ok(content) = std::fs::read_to_string(&package_json) {
            if let Ok(json) = serde_json::from_str::<serde_json::Value>(&content) {
                // Try "exports" field first (modern)
                if let Some(exports) = json.get("exports") {
                    if let Some(resolved) = resolve_exports(exports, package_dir, ".") {
                        return Some(resolved);
                    }
                }

                // Try "types" field (for type definitions)
                if let Some(types) = json.get("types").or_else(|| json.get("typings")) {
                    if let Some(types_str) = types.as_str() {
                        let types_path = package_dir.join(types_str);
                        if types_path.is_file() {
                            return Some(types_path);
                        }
                    }
                }

                // Try "main" field
                if let Some(main) = json.get("main") {
                    if let Some(main_str) = main.as_str() {
                        let main_path = package_dir.join(main_str);
                        if let Some(resolved) = try_resolve_file(&main_path) {
                            return Some(resolved);
                        }
                    }
                }
            }
        }
    }

    // Fallback to index file
    try_resolve_file(&package_dir.join("index"))
}

/// Resolve package.json exports field
fn resolve_exports(
    exports: &serde_json::Value,
    package_dir: &Path,
    subpath: &str,
) -> Option<PathBuf> {
    match exports {
        serde_json::Value::String(s) => {
            if subpath == "." {
                let path = package_dir.join(s.trim_start_matches("./"));
                return try_resolve_file(&path);
            }
        }
        serde_json::Value::Object(map) => {
            // Try to find the subpath
            if let Some(entry) = map.get(subpath) {
                return resolve_export_entry(entry, package_dir);
            }

            // Try "." for default export
            if subpath == "." {
                if let Some(entry) = map.get(".") {
                    return resolve_export_entry(entry, package_dir);
                }
            }
        }
        _ => {}
    }
    None
}

/// Resolve a single export entry
fn resolve_export_entry(entry: &serde_json::Value, package_dir: &Path) -> Option<PathBuf> {
    match entry {
        serde_json::Value::String(s) => {
            let path = package_dir.join(s.trim_start_matches("./"));
            try_resolve_file(&path)
        }
        serde_json::Value::Object(map) => {
            // Try conditions in order of preference
            let conditions = ["types", "import", "require", "default"];
            for condition in conditions {
                if let Some(value) = map.get(condition) {
                    if let Some(resolved) = resolve_export_entry(value, package_dir) {
                        return Some(resolved);
                    }
                }
            }
            None
        }
        _ => None,
    }
}

/// Try to resolve a file path with extensions
fn try_resolve_file(path: &Path) -> Option<PathBuf> {
    // If path exists as-is
    if path.is_file() {
        return Some(path.to_path_buf());
    }

    // Try with extensions
    let extensions = [".ts", ".tsx", ".d.ts", ".js", ".jsx", ".mts", ".mjs"];
    for ext in extensions {
        let with_ext = path.with_extension(ext.trim_start_matches('.'));
        if with_ext.is_file() {
            return Some(with_ext);
        }
    }

    // Try as directory with index
    if path.is_dir() {
        for ext in extensions {
            let index = path.join(format!("index{}", ext));
            if index.is_file() {
                return Some(index);
            }
        }
    }

    None
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_parse_package_specifier_simple() {
        let (name, subpath) = parse_package_specifier("lodash");
        assert_eq!(name, "lodash");
        assert!(subpath.is_none());
    }

    #[test]
    fn test_parse_package_specifier_with_subpath() {
        let (name, subpath) = parse_package_specifier("lodash/fp");
        assert_eq!(name, "lodash");
        assert_eq!(subpath, Some("fp".to_string()));
    }

    #[test]
    fn test_parse_package_specifier_scoped() {
        let (name, subpath) = parse_package_specifier("@types/node");
        assert_eq!(name, "@types/node");
        assert!(subpath.is_none());
    }

    #[test]
    fn test_parse_package_specifier_scoped_with_subpath() {
        let (name, subpath) = parse_package_specifier("@angular/core/testing");
        assert_eq!(name, "@angular/core");
        assert_eq!(subpath, Some("testing".to_string()));
    }

    #[test]
    fn test_parse_package_specifier_complex_subpath() {
        let (name, subpath) = parse_package_specifier("lodash/fp/curry");
        assert_eq!(name, "lodash");
        assert_eq!(subpath, Some("fp/curry".to_string()));
    }

    #[test]
    fn test_try_resolve_file_nonexistent() {
        let result = try_resolve_file(&PathBuf::from("/nonexistent/file"));
        assert!(result.is_none());
    }

    #[test]
    fn test_try_resolve_file_exists() {
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("test.ts");
        fs::write(&file_path, "export {}").unwrap();

        let result = try_resolve_file(&file_path);
        assert!(result.is_some());
        assert_eq!(result.unwrap(), file_path);
    }

    #[test]
    fn test_try_resolve_file_with_extension() {
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("test.ts");
        fs::write(&file_path, "export {}").unwrap();

        // Try to resolve without extension
        let base_path = temp_dir.path().join("test");
        let result = try_resolve_file(&base_path);
        assert!(result.is_some());
    }

    #[test]
    fn test_try_resolve_file_index() {
        let temp_dir = TempDir::new().unwrap();
        let dir_path = temp_dir.path().join("utils");
        fs::create_dir(&dir_path).unwrap();
        fs::write(dir_path.join("index.ts"), "export {}").unwrap();

        let result = try_resolve_file(&dir_path);
        assert!(result.is_some());
        assert!(result.unwrap().ends_with("index.ts"));
    }

    #[test]
    fn test_resolve_node_module_not_found() {
        let temp_dir = TempDir::new().unwrap();
        let result = resolve_node_module("nonexistent", temp_dir.path());
        assert!(result.is_none());
    }

    #[test]
    fn test_resolve_node_module_simple() {
        let temp_dir = TempDir::new().unwrap();

        // Create node_modules/lodash/index.js
        let lodash_dir = temp_dir.path().join("node_modules").join("lodash");
        fs::create_dir_all(&lodash_dir).unwrap();
        fs::write(lodash_dir.join("index.js"), "module.exports = {}").unwrap();

        let result = resolve_node_module("lodash", temp_dir.path());
        assert!(result.is_some());
    }

    #[test]
    fn test_resolve_node_module_with_package_json_main() {
        let temp_dir = TempDir::new().unwrap();

        let lodash_dir = temp_dir.path().join("node_modules").join("lodash");
        fs::create_dir_all(&lodash_dir).unwrap();

        fs::write(
            lodash_dir.join("package.json"),
            r#"{"main": "./dist/lodash.js"}"#,
        )
        .unwrap();

        let dist_dir = lodash_dir.join("dist");
        fs::create_dir(&dist_dir).unwrap();
        fs::write(dist_dir.join("lodash.js"), "module.exports = {}").unwrap();

        let result = resolve_node_module("lodash", temp_dir.path());
        assert!(result.is_some());
    }

    #[test]
    fn test_resolve_node_module_with_types() {
        let temp_dir = TempDir::new().unwrap();

        let lodash_dir = temp_dir.path().join("node_modules").join("lodash");
        fs::create_dir_all(&lodash_dir).unwrap();

        fs::write(
            lodash_dir.join("package.json"),
            r#"{"types": "./index.d.ts"}"#,
        )
        .unwrap();
        fs::write(lodash_dir.join("index.d.ts"), "export {}").unwrap();

        let result = resolve_node_module("lodash", temp_dir.path());
        assert!(result.is_some());
    }

    #[test]
    fn test_resolve_node_module_with_exports() {
        let temp_dir = TempDir::new().unwrap();

        let lodash_dir = temp_dir.path().join("node_modules").join("lodash");
        fs::create_dir_all(&lodash_dir).unwrap();

        fs::write(
            lodash_dir.join("package.json"),
            r#"{"exports": {"." : "./index.js"}}"#,
        )
        .unwrap();
        fs::write(lodash_dir.join("index.js"), "module.exports = {}").unwrap();

        let result = resolve_node_module("lodash", temp_dir.path());
        assert!(result.is_some());
    }

    #[test]
    fn test_resolve_node_module_subpath() {
        let temp_dir = TempDir::new().unwrap();

        let lodash_dir = temp_dir.path().join("node_modules").join("lodash");
        fs::create_dir_all(&lodash_dir).unwrap();

        let fp_dir = lodash_dir.join("fp");
        fs::create_dir(&fp_dir).unwrap();
        fs::write(fp_dir.join("index.js"), "module.exports = {}").unwrap();

        let result = resolve_node_module("lodash/fp", temp_dir.path());
        assert!(result.is_some());
    }

    #[test]
    fn test_resolve_node_module_walks_up() {
        let temp_dir = TempDir::new().unwrap();

        // Create node_modules at root
        let lodash_dir = temp_dir.path().join("node_modules").join("lodash");
        fs::create_dir_all(&lodash_dir).unwrap();
        fs::write(lodash_dir.join("index.js"), "module.exports = {}").unwrap();

        // Create nested directory
        let nested = temp_dir.path().join("src").join("deep").join("nested");
        fs::create_dir_all(&nested).unwrap();

        let result = resolve_node_module("lodash", &nested);
        assert!(result.is_some());
    }

    #[test]
    fn test_resolve_node_module_scoped() {
        let temp_dir = TempDir::new().unwrap();

        let types_dir = temp_dir
            .path()
            .join("node_modules")
            .join("@types")
            .join("node");
        fs::create_dir_all(&types_dir).unwrap();
        fs::write(types_dir.join("index.d.ts"), "export {}").unwrap();

        let result = resolve_node_module("@types/node", temp_dir.path());
        assert!(result.is_some());
    }

    #[test]
    fn test_resolve_exports_string() {
        let temp_dir = TempDir::new().unwrap();
        fs::write(temp_dir.path().join("index.js"), "module.exports = {}").unwrap();

        let exports = serde_json::json!("./index.js");
        let result = resolve_exports(&exports, temp_dir.path(), ".");
        assert!(result.is_some());
    }

    #[test]
    fn test_resolve_exports_object() {
        let temp_dir = TempDir::new().unwrap();
        fs::write(temp_dir.path().join("index.js"), "module.exports = {}").unwrap();

        let exports = serde_json::json!({
            ".": "./index.js"
        });
        let result = resolve_exports(&exports, temp_dir.path(), ".");
        assert!(result.is_some());
    }

    #[test]
    fn test_resolve_exports_conditional() {
        let temp_dir = TempDir::new().unwrap();
        fs::write(temp_dir.path().join("index.js"), "module.exports = {}").unwrap();

        let exports = serde_json::json!({
            ".": {
                "import": "./index.js",
                "require": "./index.cjs"
            }
        });
        let result = resolve_exports(&exports, temp_dir.path(), ".");
        assert!(result.is_some());
    }

    #[test]
    fn test_resolve_exports_types_priority() {
        let temp_dir = TempDir::new().unwrap();
        fs::write(temp_dir.path().join("index.d.ts"), "export {}").unwrap();
        fs::write(temp_dir.path().join("index.js"), "module.exports = {}").unwrap();

        let exports = serde_json::json!({
            ".": {
                "types": "./index.d.ts",
                "import": "./index.js"
            }
        });
        let result = resolve_exports(&exports, temp_dir.path(), ".");
        assert!(result.is_some());
        // Should prefer types
        assert!(result.unwrap().to_string_lossy().contains("index.d.ts"));
    }

    #[test]
    fn test_resolve_export_entry_string() {
        let temp_dir = TempDir::new().unwrap();
        fs::write(temp_dir.path().join("index.js"), "module.exports = {}").unwrap();

        let entry = serde_json::json!("./index.js");
        let result = resolve_export_entry(&entry, temp_dir.path());
        assert!(result.is_some());
    }

    #[test]
    fn test_resolve_export_entry_not_found() {
        let temp_dir = TempDir::new().unwrap();

        let entry = serde_json::json!("./nonexistent.js");
        let result = resolve_export_entry(&entry, temp_dir.path());
        assert!(result.is_none());
    }

    #[test]
    fn test_resolve_package_entry_with_typings() {
        let temp_dir = TempDir::new().unwrap();

        fs::write(
            temp_dir.path().join("package.json"),
            r#"{"typings": "./types.d.ts"}"#,
        )
        .unwrap();
        fs::write(temp_dir.path().join("types.d.ts"), "export {}").unwrap();

        let result = resolve_package_entry(temp_dir.path(), None);
        assert!(result.is_some());
    }

    #[test]
    fn test_resolve_package_entry_subpath() {
        let temp_dir = TempDir::new().unwrap();

        let utils_dir = temp_dir.path().join("utils");
        fs::create_dir(&utils_dir).unwrap();
        fs::write(utils_dir.join("index.ts"), "export {}").unwrap();

        let result = resolve_package_entry(temp_dir.path(), Some("utils"));
        assert!(result.is_some());
    }
}
